local start_gcode = [[
; Generated by sZo/laytogcode.lua
G91
G1 X-2 Y-2 F60
G90
G92 X0 Y0 Z0 E0; Reset all axes to zero.
;
;
;
]]

local end_gcode = [[
;
;
;
G28 X Y; Auto home. Do not park Z here to prevent scrath off PCB.
G28 Z
;
]]

local Z_insert_gcode = "G1 Z0 F60\n"
local Z_retract_gcode = "G1 Z0.5 F60\n"

local MARKER_THICKNESS = 0.8 -- Толщина маркера, не используется.
local MARKER_OVERLAP = 0.15
local N_CIRCLE_STEPS = 8 -- Число шагов для генерации круга прямыми ходами
local MOVE_SPEED = 12000 -- 200мм/с (1200мм/мин)
local PAINT_SPEED = 360

local SELECTED_LAYER = 3
local N_REPETITIONS = 3

local lay_file = io.open("Meteo station.txt", "rb")
assert(lay_file, "Input file not found.")
local gcode_file = io.open("output.gcode", "wb")
assert(gcode_file, "Output file not found.")

gcode_file:write(start_gcode)

local tracks = {}
local pads = {}
local smdpads = {}

print("Parsing file...")

for line in lay_file:lines() do
  local obj_type, line = string.match(line, "(%a+)[,;](.*)")
  local obj = {}
  while line do
    local properity, value, l = string.match(line, "([^=]+)=([^,;]+)[,;](.*)")
    if properity then
      obj[properity] = value
    end
    line = l
  end
  if tonumber(obj["LAYER"]) == SELECTED_LAYER then
    if obj_type == "TRACK" then
      table.insert(tracks, obj)
    elseif obj_type == "PAD" then
      table.insert(pads, obj)
    elseif obj_type == "SMDPAD" then
      table.insert(smdpads, obj)
    end
  end
end

print("Found",  #tracks, "tracks.")
print("Found",  #pads, "pads.")
print("Found",  #smdpads, "smd pads.")

--################
--#   DECODING   #
--################

local min_x = math.huge
local min_y = math.huge

print("Calculating tracks positions...")

for i = 1, #tracks, 1 do
  local track = tracks[i]
  track.points = {}
  track.width = tonumber(track["WIDTH"]) / 10000
  for f, v in pairs(track) do
    local l, n = string.match(f, "(%a)(%d+)")
    if l and n then
      local x = 0
      local y = 0
      local dx, dy = string.match(v, "(%d*)/(%d*)")
      x = dx / 10000
      y = dy / 10000
      min_x = x < min_x and x or min_x
      min_y = y < min_y and y or min_y
      n = tonumber(n) + 1
      track.points[n] = {x, y}
    end
  end
end

print("Min x:", min_x)
print("Min_y:", min_y)

print("Calculating pads positions...")

for i_pad = 1, #pads, 1 do
  local pad = pads[i_pad]
  local dx, dy = string.match(pad["POS"], "(%d*)/(%d*)")
  pad.x = dx / 10000
  pad.y = dy / 10000
  pad.diameter = tonumber(pad.SIZE) / 10000
  pad.inner_diameter = tonumber(pad.DRILL) / 10000
end

print("Calculating smdpads positions...")

for i_pad = 1, #smdpads, 1 do
  local pad = smdpads[i_pad]
  local dx, dy = string.match(pad["POS"], "(%d*)/(%d*)")
  pad.x = dx / 10000
  pad.y = dy / 10000
  pad.size_x = tonumber(pad["SIZE_X"]) / 10000
  pad.size_y = tonumber(pad["SIZE_Y"]) / 10000
  pad.rotation = tonumber(pad["ROTATION"] or 0) / 100
end

--################
--#   MOVEMENT   #
--################

local machine_x, machine_y = 0, 0
local function g_goto(x, y)
  if machine_x ~= x or machine_y ~= y then
    gcode_file:write(Z_retract_gcode)
    gcode_file:write("G1 X" .. tostring(x) .. " Y" .. tostring(y) .. " F"  .. tostring(MOVE_SPEED) .."\n")
    gcode_file:write(Z_insert_gcode)
    machine_x, machine_y = x, y
  end
end

local function g_line(x, y)
  gcode_file:write("G1 X" .. tostring(x) .. " Y" .. tostring(y) .. " F"  .. tostring(PAINT_SPEED) .."\n")
end

local function g_circle(x, y, d)
  local r = d / 2
  g_goto(x + r, y)
  for i = 1, N_CIRCLE_STEPS, 1 do
    local angle = i / N_CIRCLE_STEPS * 6.28
    local xm = math.cos(angle)
    local ym = math.sin(angle)
    g_line(x + (xm * r), y + (ym * r))
  end
end

local function g_infillcircle(x, y, d)
  local s = MARKER_THICKNESS - MARKER_OVERLAP
  local n = math.floor(d / 2 / s)
  
  g_goto(x, y)
  for i = 1, n, 1 do
    g_circle(x, y, i * s)
  end
end

local function g_infilline(sx, sy, ex, ey, d)
  --print("L:", sx, sy, ex, ey, d)
  local s = MARKER_THICKNESS - MARKER_OVERLAP
  local n = math.floor(d / 2 / s)
  local dx = ex - sx
  local dy = ey - sy
  local l = ((dx ^ 2) + (dy ^ 2)) ^ 0.5
  local xm = dx / l
  local ym = dy / l
  --print("P:", l, xm, ym, dx, dy)
  
  g_goto(sx, sy)
  g_line(ex, ey)
  for i = 1, n, 1 do
    local psxp = sx - ym * i * s
    local psyp = sy + xm * i * s
    local pexp = ex - ym * i * s
    local peyp = ey + xm * i * s
    g_goto(psxp, psyp)
    g_line(pexp, peyp)
    local nsxp = sx + ym * i * s
    local nsyp = sy - xm * i * s
    local nexp = ex + ym * i * s
    local neyp = ey - xm * i * s
    g_goto(nexp, neyp)
    g_line(nsxp, nsyp)
  end
end

local function g_infillrect(sx, sy, ex, ey)
  local s = MARKER_THICKNESS - MARKER_OVERLAP
  g_goto(sx, sy)
  g_line(ex, sy)
  g_line(ex, ey)
  g_line(sx, ey)
  g_line(sx, sy)
  
  local dy = sy - ey
  local n = math.abs(math.ceil(dy / s))
  for i = 1, n, 1 do
    local ty = sy + i * s
    g_goto(sx, ty)
    g_line(ex, ty)
  end
end

--################
--#  GENERATION  #
--################

for i_repetition = 1, N_REPETITIONS, 1 do

  print("Generating tracks G-codes...")

  for i_track = 1, #tracks, 1 do
    local track = tracks[i_track]
    local points = track.points
    local px = points[1][1]
    local py = points[1][2]
    gcode_file:write("; TRACK " .. tostring(i_track) .. "\n")
    for i_points = 2, #points, 1 do
      local point = points[i_points]
      local x = point[1]
      local y = point[2]
      g_infilline(x, y, px, py, track.width)
      px = x
      py = y
    end
  end

  print("Generating smdpads G-codes...")

  for i_pad = 1, #smdpads, 1 do
    local pad = smdpads[i_pad]
    gcode_file:write("; SMDPAD " .. tostring(i_pad) .. "\n")
    local x = pad.x
    local y = pad.y
    local w = pad.size_x
    local l = pad.size_y
    local rotation = pad.rotation
    local hw = w / 2
    local hl = l / 2
    local xm = math.cos(math.rad(rotation))
    local ym = math.sin(math.rad(rotation))
    local hdx = hw * xm + hl * ym
    local hdy = hw * ym + hl * xm
    g_infillrect(x - hdx, y - hdy, x + hdx, y + hdy)
  end

  print("Generating pad G-codes...")

  for i_pad = 1, #pads, 1 do
    local pad = pads[i_pad]
    gcode_file:write("; PAD " .. tostring(i_pad) .. "\n")
    local x = pad.x
    local y = pad.y
    local d = pad.diameter
    g_infillcircle(x, y, d)
  end

end

gcode_file:write(end_gcode)
gcode_file:close()

